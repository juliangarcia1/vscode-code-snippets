{	// Basic Structure
	"package main": {
        "prefix": "package",
        "body": ["package main"]
      },
      "main function": {
        "prefix": "main",
        "body": ["func main() {", "\t$0", "}"]
      },
      // Print to Console
      "fmt.Println": {
        "prefix": "println",
        "body": ["fmt.Println($0)"]
      },
      // Variables
      "var declaration": {
        "prefix": "var",
        "body": ["var $1 $0"]
      },
      // Constants
      "const declaration": {
        "prefix": "const",
        "body": ["const $1 = $0"]
      },
      // If statement
      "if statement": {
        "prefix": "if",
        "body": ["if $1 {", "\t$0", "}"]
      },
      // If-else statement
      "if-else statement": {
        "prefix": "ife",
        "body": ["if $1 {", "\t$2", "} else {", "\t$3", "}"]
      },
      // For loop
      "for loop": {
        "prefix": "for",
        "body": ["for $1 {", "\t$0", "}"]
      },
      // Function
      "function declaration": {
        "prefix": "func",
        "body": ["func $1($2) $3 {", "\t$0", "}"]
      },
      // Struct
      "struct declaration": {
        "prefix": "struct",
        "body": ["type $1 struct {", "\t$0", "}"]
      },
      // Method
      "method declaration": {
        "prefix": "method",
        "body": ["func ($1 *$2) $3($4) $5 {", "\t$0", "}"]
      },
      // Error Handling
      "error check": {
        "prefix": "errchk",
        "body": ["if err != nil {", "\t$0", "}"]
      },
      // Slices
      "slice declaration": {
        "prefix": "slice",
        "body": ["$1 := make([]$2, $3)"]
      },
      // Maps
      "map declaration": {
        "prefix": "map",
        "body": ["$1 := make(map[$2]$3)"]
      },
      // Defer Statement
      "defer statement": {
        "prefix": "defer",
        "body": ["defer $1($2)"]
      },
      // Panic and Recover
      "panic statement": {
        "prefix": "panic",
        "body": ["panic($1)"]
      },
      "recover statement": {
        "prefix": "recover",
        "body": ["if r := recover(); r != nil {", "\t$0", "}"]
      },
      // Channels
      "channel declaration": {
        "prefix": "chan",
        "body": ["$1 := make(chan $2)"]
      },
      // Select Statement
      "select statement": {
        "prefix": "select",
        "body": ["select {", "\tcase $1:", "\t\t$2", "\tdefault:", "\t\t$3", "}"]
      },
      // Mutex
      "mutex declaration": {
        "prefix": "mutex",
        "body": ["var $1 sync.Mutex"]
      },
      // WaitGroup
      "waitgroup declaration": {
        "prefix": "waitgroup",
        "body": ["var $1 sync.WaitGroup"]
      },
      // Time
      "time sleep": {
        "prefix": "sleep",
        "body": ["time.Sleep($1)"]
      },
      // JSON Marshal and Unmarshal
      "json marshal": {
        "prefix": "marshal",
        "body": ["data, err := json.Marshal($1)"]
      },
      "json unmarshal": {
        "prefix": "unmarshal",
        "body": ["err := json.Unmarshal($1, &$2)"]
      },
      // HTTP Server
      "http server": {
        "prefix": "http",
        "body": [
          "func main() {",
          "\thttp.HandleFunc(\"/$1\", $2)",
          "\terr := http.ListenAndServe(\":8080\", nil)",
          "\tif err != nil {",
          "\t\tlog.Fatal(err)",
          "\t}",
          "}"
        ]
      },
      //iota constant
      "iota constant": {
        "prefix": "iota",
        "body": [
            "const (",
            "\t${1:Constant1} = iota",
            "\t${2:Constant2}",
            "\t${3:Constant3}",
            "\t// Add more constants as needed",
            ")"
        ],
        "description": "Create iota constants"
      },
      //interface
      "interface": {
          "prefix": "interface",
          "body": [
              "type ${1|InterfaceName|MyInterface|}${1} interface {",
              "\t${2:MethodName}() ${3|ReturnType|error}",
              "\t// Add more methods as needed",
              "}",
          ],
          "description": "Create a Go interface"
      } 
      //interface and implementation
      "interface and implementation": {
        "prefix": "interface",
        "body": [
            "type ${1|InterfaceName|MyInterface|}${1} interface {",
            "\t${2:Method1}() ${3|ReturnType1|error}",
            "\t${4:Method2}(${5|param1|arg1} ${6|ParamType1|int}) ${7|ReturnType2|string}",
            "\t// Add more methods as needed",
            "}",
            "",
            "type ${8|StructName|MyStruct|}${8} struct {}",
            "",
            "func (s *${8|StructName|MyStruct|}) ${2:Method1}() ${3|ReturnType1|error} {",
            "\t// Implementation for ${2:Method1}",
            "\treturn ${9|nil|errors.New(\"Not implemented\")}",
            "}",
            "",
            "func (s *${8|StructName|MyStruct|}) ${4:Method2}(${5|param1|arg1} ${6|ParamType1|int}) ${7|ReturnType2|string} {",
            "\t// Implementation for ${4:Method2}",
            "\treturn ${10|\"\", nil|\"Not implemented\", errors.New(\"Not implemented\")}",
            "}",
            "",
            "// Add more methods implementations as needed",
        ],
        "description": "Create interface and its implementation"
    }
      // Design patterns
      "singleton": {
		"prefix": "singleton",
		"body": [
		  "type ${1:Singleton} struct {",
		  "\t// fields",
		  "}",
		  "",
		  "var ${2|instance,singletonInstance,_instance|}${1} *${1:Singleton}",
		  "",
		  "func Get${1}Instance() *${1:Singleton} {",
		  "\tif ${2|instance,singletonInstance,_instance|}${1} == nil {",
		  "\t\t${2|instance,singletonInstance,_instance|}${1} = &${1:Singleton}{",
		  "\t\t\t// initialize fields",
		  "\t\t}",
		  "\t}",
		  "\treturn ${2|instance,singletonInstance,_instance|}${1}",
		  "}",
		]
	  },
	  "singleton_test": {
		"prefix": "singleton_test",
		"body": [
		  "func TestGet${1}Instance(t *testing.T) {",
		  "\tinstance1 := Get${1}Instance()",
		  "\tinstance2 := Get${1}Instance()",
		  "\tif instance1 != instance2 {",
		  "\t\tt.Errorf(\"instance1 != instance2\")",
		  "\t}",
		  "}",	
		]
	  },						
	  "builder": {
		"prefix": "builder",
		"body": [
		  "type ${1:Product} struct {",
		  "\t// fields",
		  "}",
		  "",
		  "type ${2:Builder} interface {",
		  "\tBuildPart1()",
		  "\tBuildPart2()",
		  "\tGetProduct() *${1:Product}",
		  "}",
		  "",
		  "type ${3:ConcreteBuilder} struct {",
		  "\tproduct *${1:Product}",
		  "}",
		  "",
		  "func (b *${3:ConcreteBuilder}) BuildPart1() {",
		  "\tb.product.Part1 = // build Part1",
		  "}",
		  "",
		  "func (b *${3:ConcreteBuilder}) BuildPart2() {",
		  "\tb.product.Part2 = // build Part2",
		  "}",
		  "",
		  "func (b *${3:ConcreteBuilder}) GetProduct() *${1:Product} {",
		  "\treturn b.product",
		  "}",
		  "",
		  "func New${3:ConcreteBuilder}() ${2:Builder} {",
		  "\treturn &${3:ConcreteBuilder}{product: &${1:Product}{}}",
		  "}",
		]
	  },
	  "builder_test": {
		"prefix": "builder_test",
		"body": [
		  "func Test${3:ConcreteBuilder}(t *testing.T) {",
		  "\tdirector := New${4:Director}(New${3:ConcreteBuilder}())",
		  "\tproduct := director.Construct()",
		  "\tif product.Part1 != // expected value {",
		  "\t\tt.Errorf(\"product.Part1 != // expected value\")",
		  "\t}",
		  "\tif product.Part2 != // expected value {",
		  "\t\tt.Errorf(\"product.Part2 != // expected value\")",
		  "\t}",
		  "}",
		]
	  },
	  "factory method": {
		"prefix": "factory",
		"body": [
		  "type ${1:Product} interface {",
		  "\tOperation()",
		  "}",
		  "",
		  "type ${2:ConcreteProduct} struct {}",
		  "",
		  "func (p *${2:ConcreteProduct}) Operation() {",
		  "\t// implementation",
		  "}",
		  "",
		  "type ${3:Creator} interface {",
		  "\tFactoryMethod() ${1:Product}",
		  "}",
		  "",
		  "type ${4:ConcreteCreator} struct {}",
		  "",
		  "func (c *${4:ConcreteCreator}) FactoryMethod() ${1:Product} {",
		  "\treturn &${2:ConcreteProduct}{}",
		  "}",
		]
	  },
	  "factory method_test": {
		"prefix": "factory_test",
		"body": [
		  "func Test${4:ConcreteCreator}(t *testing.T) {",
		  "\tcreator := &${4:ConcreteCreator}{}",
		  "\tproduct := creator.FactoryMethod()",
		  "\tproduct.Operation()",
		  "}",
		]
	  },
	  "abstract factory": {
		"prefix": "abstract",
		"body": [
			"type ${1:AbstractProductA} interface {",
			"\tMethodA()",
			"}",
			"",
			"type ${2:ConcreteProductA1} struct {}",
			"",
			"func (p *${2:ConcreteProductA1}) MethodA() {",
			"\t// implementation",
			"}",
			"",
			"type ${3:AbstractProductB} interface {",
			"\tMethodB()",
			"}",
			"",
			"type ${4:ConcreteProductB1} struct {}",
			"",
			"func (p *${4:ConcreteProductB1}) MethodB() {",
			"\t// implementation",
			"}",
			"",
			"type ${5:AbstractFactory} interface {",
			"\tCreateProductA() ${1:AbstractProductA}",
			"\tCreateProductB() ${3:AbstractProductB}",
			"}",
			"",
			"type ${6:ConcreteFactory1} struct {}",
			"",
			"func (f *${6:ConcreteFactory1}) CreateProductA() ${1:AbstractProductA} {",
			"\treturn &${2:ConcreteProductA1}{}",
			"}",
			"",
			"func (f *${6:ConcreteFactory1}) CreateProductB() ${3:AbstractProductB} {",
			"\treturn &${4:ConcreteProductB1}{}",
			"}",
		]
		},
		"abstract factory_test": {
			"prefix": "abstract_test",
			"body": [
				"func Test${6:ConcreteFactory1}(t *testing.T) {",
				"\tfactory := &${6:ConcreteFactory1}{}",
				"\tproductA := factory.CreateProductA()",
				"\tproductA.MethodA()",
				"\tproductB := factory.CreateProductB()",
				"\tproductB.MethodB()",
				"}",
			]
		},
		"prototype": {
			"prefix": "prototype",
			"body": [
			  "type ${1:Cloneable} interface {",
			  "\tClone() ${1:Cloneable}",
			  "}",
			  "",
			  "type ${2:ConcretePrototype} struct {",
			  "\t// fields",
			  "}",
			  "",
			  "func (p *${2:ConcretePrototype}) Clone() ${1:Cloneable} {",
			  "\treturn &${2:ConcretePrototype}{",
			  "\t\t// copy fields",
			  "\t}",
			  "}",
			]
		  },
		"prototype_test": {	
			"prefix": "prototype_test",
			"body": [
			  "func Test${2:ConcretePrototype}(t *testing.T) {",
			  "\tprototype := &${2:ConcretePrototype}{}",
			  "\tclone := prototype.Clone()",
			  "\tif prototype != clone {",
			  "\t\tt.Errorf(\"prototype != clone\")",
			  "\t}",
			  "}",
			]
		  },
		"adapter": {
			"prefix": "adapter",
			"body": [
			  "type ${1:Target} interface {",
			  "\tRequest()",
			  "}",
			  "",
			  "type ${2:Adaptee} struct {}",
			  "",
			  "func (a *${2:Adaptee}) SpecificRequest() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${3:Adapter} struct {",
			  "\tadaptee *${2:Adaptee}",
			  "}",
			  "",
			  "func (a *${3:Adapter}) Request() {",
			  "\ta.adaptee.SpecificRequest()",
			  "}",
			  "",
			  "func New${3:Adapter}(adaptee *${2:Adaptee}) ${1:Target} {",
			  "\treturn &${3:Adapter}{adaptee: adaptee}",
			  "}",
			]
		  },
		"adapter_test": {
			"prefix": "adapter_test",
			"body": [
			  "func Test${3:Adapter}(t *testing.T) {",
			  "\tadaptee := &${2:Adaptee}{}",
			  "\ttarget := New${3:Adapter}(adaptee)",
			  "\ttarget.Request()",
			  "}",
			]
		  },
		"decorator": {
			"prefix": "decorator",
			"body": [
			  "type ${1:Component} interface {",
			  "\tOperation()",
			  "}",
			  "",
			  "type ${2:ConcreteComponent} struct {}",
			  "",
			  "func (c *${2:ConcreteComponent}) Operation() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${3:Decorator} struct {",
			  "\tcomponent ${1:Component}",
			  "}",
			  "",
			  "func (d *${3:Decorator}) Operation() {",
			  "\td.component.Operation()",
			  "}",
			  "",
			  "type ${4:ConcreteDecorator} struct {",
			  "\t${3:Decorator}",
			  "}",
			  "",
			  "func (d *${4:ConcreteDecorator}) Operation() {",
			  "\td.component.Operation()",
			  "\t// additional decoration",
			  "}",
			  "",
			  "func New${4:ConcreteDecorator}(component ${1:Component}) ${1:Component} {",
			  "\treturn &${4:ConcreteDecorator}{Decorator: ${3:Decorator}{component: component}}",
			  "}",
			]
		  },
		"decorator_test": {
			"prefix": "decorator_test",
			"body": [
			  "func Test${4:ConcreteDecorator}(t *testing.T) {",
			  "\tcomponent := &${2:ConcreteComponent}{}",
			  "\tdecorator := New${4:ConcreteDecorator}(component)",
			  "\tdecorator.Operation()",
			  "}",
			]
		  },
		"proxy": {
			"prefix": "proxy",
			"body": [
			  "type ${1:Subject} interface {",
			  "\tRequest()",
			  "}",
			  "",
			  "type ${2:RealSubject} struct {}",
			  "",
			  "func (r *${2:RealSubject}) Request() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${3:Proxy} struct {",
			  "\trealSubject *${2:RealSubject}",
			  "}",
			  "",
			  "func (p *${3:Proxy}) Request() {",
			  "\tif p.realSubject == nil {",
			  "\t\tp.realSubject = &${2:RealSubject}{}",
			  "\t}",
			  "\tp.realSubject.Request()",
			  "}",
			]
		  },
		"proxy_test": {
			"prefix": "proxy_test",
			"body": [
			  "func Test${3:Proxy}(t *testing.T) {",
			  "\tproxy := &${3:Proxy}{}",
			  "\tproxy.Request()",
			  "}",
			]
		  },
		"composite": {
			"prefix": "composite",
			"body": [
			  "type ${1:Component} interface {",
			  "\tOperation()",
			  "}",
			  "",
			  "type ${2:Leaf} struct {}",
			  "",
			  "func (l *${2:Leaf}) Operation() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${3:Composite} struct {",
			  "\tchildren []${1:Component}",
			  "}",
			  "",
			  "func (c *${3:Composite}) Operation() {",
			  "\tfor _, child := range c.children {",
			  "\t\tchild.Operation()",
			  "\t}",
			  "}",
			  "",
			  "func (c *${3:Composite}) Add(child ${1:Component}) {",
			  "\tc.children = append(c.children, child)",
			  "}",
			]
		  },
		"composite_test": {
			"prefix": "composite_test",
			"body": [
			  "func Test${3:Composite}(t *testing.T) {",
			  "\tcomponent := &${3:Composite}{}",
			  "\tcomponent.Add(&${2:Leaf}{})",
			  "\tcomponent.Operation()",
			  "}",
			]
		  },
		"bridge": {
			"prefix": "bridge",
			"body": [
			  "type ${1:Implementor} interface {",
			  "\tOperationImpl()",
			  "}",
			  "",
			  "type ${2:ConcreteImplementorA} struct {}",
			  "",
			  "func (i *${2:ConcreteImplementorA}) OperationImpl() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${3:ConcreteImplementorB} struct {}",
			  "",
			  "func (i *${3:ConcreteImplementorB}) OperationImpl() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${4:Abstraction} interface {",
			  "\tOperation()",
			  "}",
			  "",
			  "type ${5:RefinedAbstraction} struct {",
			  "\timplementor ${1:Implementor}",
			  "}",
			  "",
			  "func (r *${5:RefinedAbstraction}) Operation() {",
			  "\tr.implementor.OperationImpl()",
			  "}",
			  "",
			  "func New${5:RefinedAbstraction}(implementor ${1:Implementor}) ${4:Abstraction} {",
			  "\treturn &${5:RefinedAbstraction}{implementor: implementor}",
			  "}",
			]
		  },
		"bridge_test": {
			"prefix": "bridge_test",
			"body": [
			  "func Test${5:RefinedAbstraction}(t *testing.T) {",
			  "\timplementor := &${2:ConcreteImplementorA}{}",
			  "\tabstraction := New${5:RefinedAbstraction}(implementor)",
			  "\tabstraction.Operation()",
			  "}",
			]
		  },
		"facade": {
			"prefix": "facade",
			"body": [
			  "type ${1:Subsystem1} struct {}",
			  "",
			  "func (s *${1:Subsystem1}) Operation1() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${2:Subsystem2} struct {}",
			  "",
			  "func (s *${2:Subsystem2}) Operation2() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${3:Facade} struct {",
			  "\tsubsystem1 ${1:Subsystem1}",
			  "\tsubsystem2 ${2:Subsystem2}",
			  "}",
			  "",
			  "func (f *${3:Facade}) Operation() {",
			  "\tf.subsystem1.Operation1()",
			  "\tf.subsystem2.Operation2()",
			  "}",
			  "",
			  "func New${3:Facade}() *${3:Facade} {",
			  "\treturn &${3:Facade}{",
			  "\t\tsubsystem1: ${1:Subsystem1}{},",
			  "\t\tsubsystem2: ${2:Subsystem2}{},",
			  "\t}",
			  "}",
			]
		  },
		"facade_test": {
			"prefix": "facade_test",
			"body": [
			  "func Test${3:Facade}(t *testing.T) {",
			  "\tfacade := New${3:Facade}()",
			  "\tfacade.Operation()",
			  "}",
			]
		  },
		"flyweight": {
			"prefix": "flyweight",
			"body": [
			  "type ${1:Flyweight} interface {",
			  "\tOperation()",
			  "}",
			  "",
			  "type ${2:ConcreteFlyweight} struct {}",
			  "",
			  "func (f *${2:ConcreteFlyweight}) Operation() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${3:UnsharedConcreteFlyweight} struct {}",
			  "",
			  "func (f *${3:UnsharedConcreteFlyweight}) Operation() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${4:FlyweightFactory} struct {",
			  "\tflyweights map[string]${1:Flyweight}",
			  "}",
			  "",
			  "func (f *${4:FlyweightFactory}) GetFlyweight(key string) ${1:Flyweight} {",
			  "\tif flyweight, ok := f.flyweights[key]; ok {",
			  "\t\treturn flyweight",
			  "\t}",
			  "\tflyweight := &${2:ConcreteFlyweight}{}",
			  "\tf.flyweights[key] = flyweight",
			  "\treturn flyweight",
			  "}",
			  "",
			  "func New${4:FlyweightFactory}() *${4:FlyweightFactory} {",
			  "\treturn &${4:FlyweightFactory}{flyweights: make(map[string]${1:Flyweight})}",
			  "}",
			]
		  },
		"flyweight_test": {
			"prefix": "flyweight_test",
			"body": [
			  "func Test${4:FlyweightFactory}(t *testing.T) {",
			  "\tfactory := New${4:FlyweightFactory}()",
			  "\tfactory.GetFlyweight(\"key1\")",
			  "\tfactory.GetFlyweight(\"key2\")",
			  "}",
			]
		  },
		"chain of responsibility": {
			"prefix": "chain",
			"body": [
			  "type ${1:Handler} interface {",
			  "\tHandleRequest()",
			  "}",
			  "",
			  "type ${2:ConcreteHandler1} struct {",
			  "\tsuccessor ${1:Handler}",
			  "}",
			  "",
			  "func (h *${2:ConcreteHandler1}) HandleRequest() {",
			  "\tif h.successor != nil {",
			  "\t\th.successor.HandleRequest()",
			  "\t}",
			  "}",
			  "",
			  "type ${3:ConcreteHandler2} struct {",
			  "\tsuccessor ${1:Handler}",
			  "}",
			  "",
			  "func (h *${3:ConcreteHandler2}) HandleRequest() {",
			  "\tif h.successor != nil {",
			  "\t\th.successor.HandleRequest()",
			  "\t}",
			  "}",
			  "",
			  "func New${2:ConcreteHandler1}(successor ${1:Handler}) ${1:Handler} {",
			  "\treturn &${2:ConcreteHandler1}{successor: successor}",
			  "}",
			  "",
			  "func New${3:ConcreteHandler2}(successor ${1:Handler}) ${1:Handler} {",
			  "\treturn &${3:ConcreteHandler2}{successor: successor}",
			  "}",
			]
		  },
		"chain of responsibility_test": {
			"prefix": "chain_test",
			"body": [
			  "func Test${2:ConcreteHandler1}(t *testing.T) {",
			  "\thandler1 := New${2:ConcreteHandler1}(nil)",
			  "\thandler2 := New${3:ConcreteHandler2}(handler1)",
			  "\thandler2.HandleRequest()",
			  "}",
			]
		  },
		"command": {
			"prefix": "command",
			"body": [
			  "type ${1:Receiver} struct {}",
			  "",
			  "func (r *${1:Receiver}) Action() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${2:Command} interface {",
			  "\tExecute()",
			  "}",
			  "",
			  "type ${3:ConcreteCommand} struct {",
			  "\treceiver *${1:Receiver}",
			  "}",
			  "",
			  "func (c *${3:ConcreteCommand}) Execute() {",
			  "\tc.receiver.Action()",
			  "}",
			  "",
			  "func New${3:ConcreteCommand}(receiver *${1:Receiver}) ${2:Command} {",
			  "\treturn &${3:ConcreteCommand}{receiver: receiver}",
			  "}",
			  "",
			  "type ${4:Invoker} struct {",
			  "\tcommand ${2:Command}",
			  "}",
			  "",
			  "func (i *${4:Invoker}) SetCommand(command ${2:Command}) {",
			  "\ti.command = command",
			  "}",
			  "",
			  "func (i *${4:Invoker}) ExecuteCommand() {",
			  "\ti.command.Execute()",
			  "}",
			]
		  },
		"command_test": {
			"prefix": "command_test",
			"body": [
			  "func Test${3:ConcreteCommand}(t *testing.T) {",
			  "\treceiver := &${1:Receiver}{}",
			  "\tcommand := New${3:ConcreteCommand}(receiver)",
			  "\tinvoker := &${4:Invoker}{}",
			  "\tinvoker.SetCommand(command)",
			  "\tinvoker.ExecuteCommand()",
			  "}",
			]
		  },
		"mediator": {
			"prefix": "mediator",
			"body": [
			  "type ${1:Colleague} interface {",
			  "\tSetMediator(mediator ${2:Mediator})",
			  "\tOperation()",
			  "}",
			  "",
			  "type ${2:Mediator} interface {",
			  "\tSend(message string, colleague ${1:Colleague})",
			  "}",
			  "",
			  "type ${3:ConcreteMediator} struct {",
			  "\tcolleague1 ${1:Colleague}",
			  "\tcolleague2 ${1:Colleague}",
			  "}",
			  "",
			  "func (m *${3:ConcreteMediator}) Send(message string, colleague ${1:Colleague}) {",
			  "\tif colleague == m.colleague1 {",
			  "\t\tm.colleague2.Operation()",
			  "\t} else {",
			  "\t\tm.colleague1.Operation()",
			  "\t}",
			  "}",
			  "",
			  "type ${4:ConcreteColleague1} struct {",
			  "\tmediator ${2:Mediator}",
			  "}",
			  "",
			  "func (c *${4:ConcreteColleague1}) SetMediator(mediator ${2:Mediator}) {",
			  "\tc.mediator = mediator",
			  "}",
			  "",
			  "func (c *${4:ConcreteColleague1}) Operation() {",
			  "\tc.mediator.Send(\"message\", c)",
			  "}",
			  "",
			  "type ${5:ConcreteColleague2} struct {",
			  "\tmediator ${2:Mediator}",
			  "}",
			  "",
			  "func (c *${5:ConcreteColleague2}) SetMediator(mediator ${2:Mediator}) {",
			  "\tc.mediator = mediator",
			  "}",
			  "",
			  "func (c *${5:ConcreteColleague2}) Operation() {",
			  "\tc.mediator.Send(\"message\", c)",
			  "}",
			  "",
			  "func New${3:ConcreteMediator}() ${2:Mediator} {",
			  "\tmediator := &${3:ConcreteMediator}{}",
			  "\tcolleague1 := &${4:ConcreteColleague1}{}",
			  "\tcolleague2 := &${5:ConcreteColleague2}{}",
			  "\tmediator.colleague1 = colleague1",
			  "\tmediator.colleague2 = colleague2",
			  "\tcolleague1.SetMediator(mediator)",
			  "\tcolleague2.SetMediator(mediator)",
			  "\treturn mediator",
			  "}",
			]
		  },
		"mediator_test": {
			"prefix": "mediator_test",
			"body": [
			  "func Test${3:ConcreteMediator}(t *testing.T) {",
			  "\tmediator := New${3:ConcreteMediator}()",
			  "\tmediator.Send(\"message\", &${4:ConcreteColleague1}{})",
			  "\tmediator.Send(\"message\", &${5:ConcreteColleague2}{})",
			  "}",
			]
		  },
		"iterator": {
			"prefix": "iterator",
			"body": [
			  "type ${1:Aggregate} interface {",
			  "\tCreateIterator() ${2:Iterator}",
			  "}",
			  "",
			  "type ${2:Iterator} interface {",
			  "\tFirst()",
			  "\tNext()",
			  "\tIsDone() bool",
			  "\tCurrentItem() interface{}",
			  "}",
			  "",
			  "type ${3:ConcreteAggregate} struct {",
			  "\titems []interface{}",
			  "}",
			  "",
			  "func (a *${3:ConcreteAggregate}) CreateIterator() ${2:Iterator} {",
			  "\treturn &${4:ConcreteIterator}{aggregate: a}",
			  "}",
			  "",
			  "type ${4:ConcreteIterator} struct {",
			  "\taggregate *${3:ConcreteAggregate}",
			  "\tindex     int",
			  "}",
			  "",
			  "func (i *${4:ConcreteIterator}) First() {",
			  "\ti.index = 0",
			  "}",
			  "",
			  "func (i *${4:ConcreteIterator}) Next() {",
			  "\tif i.index < len(i.aggregate.items) {",
			  "\t\ti.index++",
			  "\t}",
			  "}",
			  "",
			  "func (i *${4:ConcreteIterator}) IsDone() bool {",
			  "\treturn i.index >= len(i.aggregate.items)",
			  "}",
			  "",
			  "func (i *${4:ConcreteIterator}) CurrentItem() interface{} {",
			  "\tif i.IsDone() {",
			  "\t\treturn nil",
			  "\t}",
			  "\treturn i.aggregate.items[i.index]",
			  "}",
			  "",
			  "func New${3:ConcreteAggregate}() ${1:Aggregate} {",
			  "\treturn &${3:ConcreteAggregate}{}",
			  "}",
			]
		  },
		"iterator_test": {
			"prefix": "iterator_test",
			"body": [
			  "func Test${4:ConcreteIterator}(t *testing.T) {",
			  "\taggregate := New${3:ConcreteAggregate}()",
			  "\taggregate.items = append(aggregate.items, 1)",
			  "\taggregate.items = append(aggregate.items, 2)",
			  "\taggregate.items = append(aggregate.items, 3)",
			  "\titerator := aggregate.CreateIterator()",
			  "\titerator.First()",
			  "\tfor !iterator.IsDone() {",
			  "\t\titerator.CurrentItem()",
			  "\t\titerator.Next()",
			  "\t}",
			  "}",
			]
		  },
		"visitor": {
			"prefix": "visitor",
			"body": [
			  "type ${1:Element} interface {",
			  "\tAccept(visitor ${2:Visitor})",
			  "}",
			  "",
			  "type ${2:Visitor} interface {",
			  "\tVisitConcreteElement1(element ${3:ConcreteElement1})",
			  "\tVisitConcreteElement2(element ${4:ConcreteElement2})",
			  "}",
			  "",
			  "type ${3:ConcreteElement1} struct {}",
			  "",
			  "func (e *${3:ConcreteElement1}) Accept(visitor ${2:Visitor}) {",
			  "\tvisitor.VisitConcreteElement1(e)",
			  "}",
			  "",
			  "type ${4:ConcreteElement2} struct {}",
			  "",
			  "func (e *${4:ConcreteElement2}) Accept(visitor ${2:Visitor}) {",
			  "\tvisitor.VisitConcreteElement2(e)",
			  "}",
			  "",
			  "type ${5:ConcreteVisitor1} struct {}",
			  "",
			  "func (v *${5:ConcreteVisitor1}) VisitConcreteElement1(element ${3:ConcreteElement1}) {",
			  "\t// implementation",
			  "}",
			  "",
			  "func (v *${5:ConcreteVisitor1}) VisitConcreteElement2(element ${4:ConcreteElement2}) {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${6:ConcreteVisitor2} struct {}",
			  "",
			  "func (v *${6:ConcreteVisitor2}) VisitConcreteElement1(element ${3:ConcreteElement1}) {",
			  "\t// implementation",
			  "}",
			  "",
			  "func (v *${6:ConcreteVisitor2}) VisitConcreteElement2(element ${4:ConcreteElement2}) {",
			  "\t// implementation",
			  "}",
			]
		  },
		"visitor_test": {
			"prefix": "visitor_test",
			"body": [
			  "func Test${5:ConcreteVisitor1}(t *testing.T) {",
			  "\telement1 := &${3:ConcreteElement1}{}",
			  "\telement2 := &${4:ConcreteElement2}{}",
			  "\tvisitor1 := &${5:ConcreteVisitor1}{}",
			  "\telement1.Accept(visitor1)",
			  "\telement2.Accept(visitor1)",
			  "\tvisitor2 := &${6:ConcreteVisitor2}{}",
			  "\telement1.Accept(visitor2)",
			  "\telement2.Accept(visitor2)",
			  "}",
			]
		  },
		"memento": {
			"prefix": "memento",
			"body": [
			  "type ${1:Memento} struct {",
			  "\tstate string",
			  "}",
			  "",
			  "func (m *${1:Memento}) GetState() string {",
			  "\treturn m.state",
			  "}",
			  "",
			  "type ${2:Originator} struct {",
			  "\tstate string",
			  "}",
			  "",
			  "func (o *${2:Originator}) SetState(state string) {",
			  "\to.state = state",
			  "}",
			  "",
			  "func (o *${2:Originator}) CreateMemento() *${1:Memento} {",
			  "\treturn &${1:Memento}{state: o.state}",
			  "}",
			  "",
			  "func (o *${2:Originator}) SetMemento(memento *${1:Memento}) {",
			  "\to.state = memento.GetState()",
			  "}",
			  "",
			  "type ${3:Caretaker} struct {",
			  "\tmemento *${1:Memento}",
			  "}",
			  "",
			  "func (c *${3:Caretaker}) GetMemento() *${1:Memento} {",
			  "\treturn c.memento",
			  "}",
			  "",
			  "func (c *${3:Caretaker}) SetMemento(memento *${1:Memento}) {",
			  "\tc.memento = memento",
			  "}",
			]
		  },
		"memento_test": {	
			"prefix": "memento_test",
			"body": [
			  "func Test${3:Caretaker}(t *testing.T) {",
			  "\toriginator := &${2:Originator}{}",
			  "\toriginator.SetState(\"state1\")",
			  "\tmemento := originator.CreateMemento()",
			  "\toriginator.SetState(\"state2\")",
			  "\toriginator.SetMemento(memento)",
			  "}",
			]
		  },
		"state": {
			"prefix": "state",
			"body": [
			  "type ${1:State} interface {",
			  "\tHandle(context *${2:Context})",
			  "}",
			  "",
			  "type ${2:Context} struct {",
			  "\tstate ${1:State}",
			  "}",
			  "",
			  "func (c *${2:Context}) Request() {",
			  "\tc.state.Handle(c)",
			  "}",
			  "",
			  "type ${3:ConcreteStateA} struct {}",
			  "",
			  "func (s *${3:ConcreteStateA}) Handle(context *${2:Context}) {",
			  "\tcontext.state = &${4:ConcreteStateB}{}",
			  "}",
			  "",
			  "type ${4:ConcreteStateB} struct {}",
			  "",
			  "func (s *${4:ConcreteStateB}) Handle(context *${2:Context}) {",
			  "\tcontext.state = &${3:ConcreteStateA}{}",
			  "}",
			]
		  },
		"state_test": {
			"prefix": "state_test",
			"body": [
			  "func Test${2:Context}(t *testing.T) {",
			  "\tcontext := &${2:Context}{state: &${3:ConcreteStateA}{}}",
			  "\tcontext.Request()",
			  "\tcontext.Request()",
			  "}",
			]
		  },
		"strategy": {
			"prefix": "strategy",
			"body": [
			  "type ${1:Strategy} interface {",
			  "\tAlgorithmInterface()",
			  "}",
			  "",
			  "type ${2:ConcreteStrategyA} struct {}",
			  "",
			  "func (s *${2:ConcreteStrategyA}) AlgorithmInterface() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${3:ConcreteStrategyB} struct {}",
			  "",
			  "func (s *${3:ConcreteStrategyB}) AlgorithmInterface() {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${4:Context} struct {",
			  "\tstrategy ${1:Strategy}",
			  "}",
			  "",
			  "func (c *${4:Context}) SetStrategy(strategy ${1:Strategy}) {",
			  "\tc.strategy = strategy",
			  "}",
			  "",
			  "func (c *${4:Context}) Algorithm() {",
			  "\tc.strategy.AlgorithmInterface()",
			  "}",
			]
		  },
		"strategy_test": {
			"prefix": "strategy_test",
			"body": [
			  "func Test${4:Context}(t *testing.T) {",
			  "\tcontext := &${4:Context}{strategy: &${2:ConcreteStrategyA}{}}",
			  "\tcontext.Algorithm()",
			  "\tcontext.SetStrategy(&${3:ConcreteStrategyB}{})",
			  "\tcontext.Algorithm()",
			  "}",
			]
		  },
		"template method": {
			"prefix": "template",
			"body": [
			  "type ${1:AbstractClass} interface {",
			  "\tPrimitiveOperation1()",
			  "\tPrimitiveOperation2()",
			  "}",
			  "",
			  "type ${2:ConcreteClass} struct {}",
			  "",
			  "func (c *${2:ConcreteClass}) PrimitiveOperation1() {",
			  "\t// implementation",
			  "}",
			  "",
			  "func (c *${2:ConcreteClass}) PrimitiveOperation2() {",
			  "\t// implementation",
			  "}",
			]
		  },
		"template method_test": {
			"prefix": "template_test",
			"body": [
			  "func Test${2:ConcreteClass}(t *testing.T) {",
			  "\tclass := &${2:ConcreteClass}{}",
			  "\tclass.PrimitiveOperation1()",
			  "\tclass.PrimitiveOperation2()",
			  "}",
			]
		  },
		"interpreter": {
			"prefix": "interpreter",
			"body": [
			  "type ${1:Context} struct {",
			  "\tinput  string",
			  "\toutput string",
			  "}",
			  "",
			  "func (c *${1:Context}) GetInput() string {",
			  "\treturn c.input",
			  "}",
			  "",
			  "func (c *${1:Context}) SetOutput(output string) {",
			  "\tc.output = output",
			  "}",
			  "",
			  "type ${2:AbstractExpression} interface {",
			  "\tInterpret(context *${1:Context})",
			  "}",
			  "",
			  "type ${3:TerminalExpression} struct {}",
			  "",
			  "func (e *${3:TerminalExpression}) Interpret(context *${1:Context}) {",
			  "\t// implementation",
			  "}",
			  "",
			  "type ${4:NonterminalExpression} struct {}",
			  "",
			  "func (e *${4:NonterminalExpression}) Interpret(context *${1:Context}) {",
			  "\t// implementation",
			  "}",
			]
		  },
		"interpreter_test": {
			"prefix": "interpreter_test",
			"body": [
			  "func Test${3:TerminalExpression}(t *testing.T) {",
			  "\tcontext := &${1:Context}{input: \"input\"}",
			  "\texpression := &${3:TerminalExpression}{}",
			  "\texpression.Interpret(context)",
			  "}",
			]
		  },
}
